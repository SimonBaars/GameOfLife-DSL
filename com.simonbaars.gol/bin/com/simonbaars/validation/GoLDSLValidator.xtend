/*
 * generated by Xtext 2.19.0
 */
package com.simonbaars.validation

import com.simonbaars.goLDSL.DSL
import com.simonbaars.goLDSL.Grid
import com.simonbaars.goLDSL.Objects
import com.simonbaars.goLDSL.Rule
import com.simonbaars.goLDSL.ShapeDef
import com.simonbaars.goLDSL.ShapeRef
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoLDSLValidator extends AbstractGoLDSLValidator {
	
	@Check
	def checkGreetingStartsWithCapital(Grid grid) {
		if(grid.size.width * grid.size.height != grid.parts.size){
			error("Grid size must correspond with specified size.", grid, null)
		}
	}
	
	@Check
	def checkShapesExist(DSL dsl) {
		var shapes = dsl.shapes;
		findNonExistentShapes((dsl.board as Objects).shapes, shapes)
		for(ShapeDef def : shapes){
			findNonExistentShapes(def.objects.shapes, shapes)
		}
		for(Rule rule : dsl.rules){
			findNonExistentShapes(rule.action.objects.shapes, shapes)
		}
	}
	
	protected def void findNonExistentShapes(EList<ShapeRef> references, EList<ShapeDef> shapes) {
		for(ShapeRef ref : references){
			if(!shapeExists(shapes, ref)){
				error("Shape does not exist: "+ref.name, ref, null)
			}
		}
	}
	
	def shapeExists(EList<ShapeDef> shapes, EList<ShapeRef> references){
		return references.stream.allMatch[ref | shapes.stream.anyMatch[shape | shape.name.equals(ref.name)]];
	}
	
	def shapeExists(EList<ShapeDef> shapes, ShapeRef ref){
		return shapes.stream.anyMatch[shape | shape.name.equals(ref.name)];
	}
	
}
